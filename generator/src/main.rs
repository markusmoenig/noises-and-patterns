use noises_and_patterns::prelude::*;

use std::fs::File;
use std::io::BufWriter;

fn main() {

    let width = 640;
    let height = 400;

    //let value = Value::new();
    //let mut bricks = Bricks::new();
    //bricks.set_property("round", 0.0);
    let noise = VoronoiBasic::new();

    // Generate

    let mut pixels = vec![0;width * height * 4];

    for y in 0..height {
        for x in 0..width {
            let v = (noise.get_2d(((x as FP) * 0.01, (y as FP) * 0.01)) + 1.0) / 2.0;
            //let v = noise.fbm_2d(((x as FP) * 1.1, (y as FP) * 0.1), 5);
            //let v = bricks.pattern_2d(((x as FP / width as FP), (y as FP / height as FP)));

            let v_u8 = (v * 255.0) as u8;
            let color = [v_u8, v_u8, v_u8, 255];

            let d = x * 4 + y * width * 4;

            pixels[d..d+4].copy_from_slice(&color);
        }
    }

    // Write to disk

    let path = "image.png";
    let file = File::create(path).unwrap();
    let ref mut w = BufWriter::new(file);

    let mut encoder = png::Encoder::new(w, width as u32, height as u32);
    encoder.set_color(png::ColorType::Rgba);
    encoder.set_depth(png::BitDepth::Eight);
    // Adding text chunks to the header
    encoder
        .add_text_chunk(
            "noises-and-patterns".to_string(),
            "This image was procedurally generated by the noises-and-patterns crate.".to_string(),
        )
        .unwrap();

    let mut writer = encoder.write_header().unwrap();

    writer.write_image_data(&pixels).unwrap();
}